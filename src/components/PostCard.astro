---
import type { CollectionEntry } from "astro:content";
import path from "node:path";
import { Icon } from "astro-icon/components";
import { getDir } from "../utils/url-utils";
import ImageWrapper from "./misc/ImageWrapper.astro";
import PostMetadata from "./PostMeta.astro";

interface Props {
  class?: string;
  entry: CollectionEntry<"posts">;
  title: string;
  url: string;
  published: Date;
  updated?: Date;
  image: string;
  description: string;
  style?: string;
  pinned?: boolean;
}

const {
  entry,
  title,
  url,
  published,
  updated,
  image,
  description,
  style,
} = Astro.props as Props;

const className = Astro.props.class as string || "";
const hasCover = !!image;
const { remarkPluginFrontmatter } = await entry.render();
---
<div class:list={["card-base relative w-full rounded-[var(--radius-large)] overflow-hidden p-6 md:p-7", className]} style={style}>
  <!-- 上半部：標題 + 圖（圖改為裁切顯示、較短高度） -->
  <div class="flex gap-4 items-start">
    <!-- 左：文字區（占剩餘空間） -->
    <div class="flex-1 min-w-0">
      <!-- 改成 items-center 讓 title 與 '>' 垂直置中 -->
      <div class="flex items-center gap-2">
        <a href={url} class="group block text-3xl font-bold text-90 mb-3 hover:text-[var(--primary)] transition truncate">
          {title}
        </a>

        {/** 如果有封面：在標題旁放一個純文字 '>' 連結（無底色、垂直置中） */}
        {hasCover && (
          <a
            href={url}
            aria-label={`進入 ${title}`}
            class="ml-1 self-center text-[1.6rem] leading-none text-[var(--primary)] no-underline hover:opacity-80 transition"
          >
            &gt;
          </a>
        )}
      </div>

      <!-- 描述 -->
      <div class="text-75 line-clamp-2">
        {description || remarkPluginFrontmatter.excerpt}
      </div>
    </div>

    <!-- 右：封面圖（裁切顯示，不會造成大空白） -->
    {hasCover && (
      <a href={url} aria-label={title} class="relative w-[28%] shrink-0 self-end rounded-xl overflow-hidden group active:scale-95 transition">
        <div class="absolute inset-0 z-10 bg-black/0 group-hover:bg-black/30 transition" />
        <div class="absolute inset-0 z-20 flex items-center justify-center pointer-events-none">
          <Icon name="material-symbols:chevron-right-rounded" class="text-white text-5xl opacity-0 scale-75 group-hover:opacity-100 group-hover:scale-100 transition" />
        </div>

        <!-- 固定高度並用 object-cover -> 會裁切而不是縮放整張圖造成空白 -->
        <div class="w-full h-[140px] md:h-[180px] lg:h-[220px]">
          <ImageWrapper
            src={image}
            basePath={path.join("content/posts/", getDir(entry.id))}
            alt="Cover Image"
            class="w-full h-full object-cover object-center"
          />
        </div>
      </a>
    )}
  </div>

  <!-- 下半部：metadata（時間、字數、分鐘） + 若無封面則右側顯示方形按鈕 -->
  <div class="mt-4 flex items-center justify-between">
    <div class="flex-1">
      <PostMetadata
        published={published}
        updated={updated}
        words={remarkPluginFrontmatter.words}
        minutes={remarkPluginFrontmatter.minutes}
        slug={entry.slug}
      />
    </div>

    {/** 若沒有封面：右側顯示方形按鈕（有底色） */}
    {!hasCover && (
      <a
        href={url}
        aria-label={`進入 ${title}`}
        class="ml-4 inline-flex items-center justify-center w-10 h-10 rounded-xl
               bg-[var(--enter-btn-bg)] hover:bg-[var(--enter-btn-bg-hover)]
               active:bg-[var(--enter-btn-bg-active)] active:scale-95 transition"
      >
        <Icon name="material-symbols:chevron-right-rounded" class="text-[var(--primary)] text-2xl" />
      </a>
    )}
  </div>
</div>

<div class="transition border-t-[1px] border-dashed mx-6 border-black/10 dark:border-white/[0.15] last:border-t-0 md:hidden"></div>

<script>
  // 保留原本的 pageviews 動畫函式（若未使用 umami 也不會影響）
  function animateValue(obj, start, end, duration) {
    let startTimestamp = null;
    const step = (timestamp) => {
      if (!startTimestamp) startTimestamp = timestamp;
      const progress = Math.min((timestamp - startTimestamp) / duration, 1);
      obj.innerHTML = Math.floor(progress * (end - start) + start);
      if (progress < 1) {
        window.requestAnimationFrame(step);
      } else {
        obj.innerHTML = end;
      }
    };
    window.requestAnimationFrame(step);
  }

  async function loadCardStats() {
    const elements = document.querySelectorAll('.post-pageviews');
    elements.forEach(async (el) => {
      if (el.classList.contains('processed') && el.textContent !== '0') return;
      el.classList.add('processed');
      const url = el.dataset.url;
      const baseUrl = el.dataset.umamiBaseUrl;
      const shareId = el.dataset.umamiShareId;
      const timezone = el.dataset.umamiTimezone;
      if (!baseUrl || !shareId) return;
      try {
        if (typeof window.fetchUmamiStats !== 'function') return;
        const statsData = await window.fetchUmamiStats(baseUrl, shareId, { url, timezone });
        const pageviews = (statsData.pageviews && statsData.pageviews.value) || statsData.pageviews || 0;
        if (statsData._fromCache) {
          el.innerHTML = pageviews;
          return;
        }
        const startVal = parseInt(el.textContent) || 0;
        if (startVal !== pageviews) {
          if (startVal === 0) {
            animateValue(el, startVal, pageviews, 1000);
          } else {
            el.innerHTML = pageviews;
          }
        }
      } catch (e) {
        console.error('Failed to load stats for', url, e);
      }
    });
  }

  document.addEventListener('DOMContentLoaded', loadCardStats);
  document.addEventListener('swup:contentReplaced', loadCardStats);
</script>
