---
import { Icon } from "astro-icon/components";
import { profileConfig } from "../../config";
import ImageWrapper from "../misc/ImageWrapper.astro";

const config = profileConfig || {};
const initialOneLiner = config.oneLiner || config.tagline || config['一句話'] || "";
---
<div class="card-base p-3">
  <!-- 頭像 -->
  <a
    aria-label="Avatar - Kairo Blog"
    href="#"
    class="group block relative mx-auto mt-1 mb-3 max-w-[12rem] h-[12rem] overflow-hidden rounded-xl active:scale-95"
  >
    <div class="absolute inset-0 pointer-events-none transition group-hover:bg-black/30 group-active:bg-black/50 z-10 flex items-center justify-center">
      <Icon name="fa6-regular:address-card" class="text-white text-5xl transition opacity-0 scale-90 group-hover:opacity-100 group-hover:scale-100" />
    </div>

    <ImageWrapper src={config.avatar || ""} alt="Profile Image" class="mx-auto w-full h-full object-cover" />
  </a>

  <!-- 名稱 -->
  <div class="px-2">
    <div class="font-bold text-xl text-center mb-1 dark:text-neutral-50">{config.name}</div>
    <div class="h-1 w-5 bg-[var(--primary)] mx-auto rounded-full mb-2"></div>

    <!-- 描述 -->
    <div class="text-center text-neutral-400 mb-2.5">
      {config.bio}
    </div>

    <!-- 按鈕（保持原樣） -->
    <div class="flex flex-wrap gap-2 justify-center mb-3">
      {config.links && config.links.length > 1 &&
        config.links.map(function (item) {
          return (
            <a rel="me" aria-label={item.name} href={item.url} target="_blank" class="btn-regular rounded-lg h-10 w-10 active:scale-90">
              <Icon name={item.icon} class="text-[1.5rem]" />
            </a>
          );
        })
      }

      {config.links && config.links.length === 1 && (
        <a rel="me" aria-label={config.links[0].name} href={config.links[0].url} target="_blank" class="btn-regular rounded-lg h-10 gap-2 px-3 font-bold active:scale-95">
          <Icon name={config.links[0].icon} class="text-[1.5rem]" />
          {config.links[0].name}
        </a>
      )}
    </div>

    <!-- 內部淺淺分隔線（不把卡片分開） + 一言（官方最簡版 + 偵錯資訊）-->
    <div class="pt-2">
      <div class="mx-4 border-t border-neutral-200/30 dark:border-neutral-700/30"></div>

      <div class="mt-2 text-center text-sm text-neutral-500 dark:text-neutral-400 italic px-3">
        <div id="poem_container" class="flex flex-col items-center gap-1">
          <!-- server-side fallback 先顯示（若有） -->
          <div id="poem_sentence" class="whitespace-pre-wrap leading-tight">{initialOneLiner}</div>
          <div id="poem_info" class="text-xs text-neutral-400 mt-1"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 下面使用官方範例的載入方式（不要 defer），並加入偵錯/timeout -->
<script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<script>
  // 調整字級（根據字數）
  function adjustFontSizeByLength(el) {
    if (!el) return;
    const text = (el.textContent || '').trim();
    const len = Array.from(text).length;
    let fontSize = 18;
    if (len <= 20) fontSize = 18;
    else if (len <= 40) fontSize = 16;
    else if (len <= 60) fontSize = 14;
    else if (len <= 100) fontSize = 13;
    else fontSize = 12;
    el.style.fontSize = fontSize + 'px';
    el.style.lineHeight = '1.25';
    el.style.maxWidth = '100%';
  }

  (function () {
    const sentenceEl = document.getElementById('poem_sentence');
    const infoEl = document.getElementById('poem_info');

    // 3s 超時處理：如果回傳沒來就顯示提示（方便偵錯）
    let callbackFired = false;
    const timeoutId = setTimeout(function () {
      if (!callbackFired) {
        console.warn('jinrishici: callback not fired within timeout');
        if (infoEl) infoEl.textContent = '（今日詩詞載入逾時）';
        adjustFontSizeByLength(sentenceEl);
      }
    }, 3000);

    try {
      if (typeof jinrishici === 'undefined' || typeof jinrishici.load !== 'function') {
        // 如果 SDK 尚未被解析（通常情況下載入後會存在），直接嘗試等待一小段時間再檢查
        console.warn('jinrishici SDK not found immediately; will attempt when ready.');
      }

      // 直接呼叫官方 load（要靠 SDK 本身處理 CORS / fetch）
      if (typeof jinrishici !== 'undefined' && typeof jinrishici.load === 'function') {
        jinrishici.load(function (result) {
          callbackFired = true;
          clearTimeout(timeoutId);
          try {
            console.log('jinrishici result:', result);
            if (!result || !result.data) {
              if (infoEl) infoEl.textContent = '（今日詩詞回傳空資料）';
              adjustFontSizeByLength(sentenceEl);
              return;
            }
            const content = (result.data.content || '').trim();
            const origin = result.data.origin || {};
            const dynasty = origin.dynasty || '';
            const author = origin.author || '';
            const title = origin.title || '';

            if (sentenceEl) {
              sentenceEl.textContent = content || sentenceEl.textContent || '';
              adjustFontSizeByLength(sentenceEl);
            }
            if (infoEl) {
              const parts = [];
              if (dynasty) parts.push('【' + dynasty + '】');
              if (author) parts.push(author);
              if (title) parts.push('《' + title + '》');
              infoEl.textContent = parts.join(' ');
            }
          } catch (e) {
            console.error('jinrishici callback error:', e);
            if (infoEl) infoEl.textContent = '（解析今日詩詞發生錯誤）';
            adjustFontSizeByLength(sentenceEl);
          }
        });
      } else {
        // SDK 可能還在載入中：嘗試在短時間內重試幾次
        let tries = 0;
        const maxTries = 40;
        const interval = setInterval(function () {
          tries++;
          if (typeof jinrishici !== 'undefined' && typeof jinrishici.load === 'function') {
            clearInterval(interval);
            try {
              jinrishici.load(function (result) {
                callbackFired = true;
                clearTimeout(timeoutId);
                try {
                  console.log('jinrishici result (delayed):', result);
                  if (!result || !result.data) {
                    if (infoEl) infoEl.textContent = '（今日詩詞回傳空資料）';
                    adjustFontSizeByLength(sentenceEl);
                    return;
                  }
                  const content = (result.data.content || '').trim();
                  const origin = result.data.origin || {};
                  const dynasty = origin.dynasty || '';
                  const author = origin.author || '';
                  const title = origin.title || '';

                  if (sentenceEl) {
                    sentenceEl.textContent = content || sentenceEl.textContent || '';
                    adjustFontSizeByLength(sentenceEl);
                  }
                  if (infoEl) {
                    const parts = [];
                    if (dynasty) parts.push('【' + dynasty + '】');
                    if (author) parts.push(author);
                    if (title) parts.push('《' + title + '》');
                    infoEl.textContent = parts.join(' ');
                  }
                } catch (e) {
                  console.error('jinrishici callback error (delayed):', e);
                  if (infoEl) infoEl.textContent = '（解析今日詩詞發生錯誤）';
                  adjustFontSizeByLength(sentenceEl);
                }
              });
            } catch (e) {
              console.error('jinrishici.load error (delayed):', e);
            }
          } else if (tries >= maxTries) {
            clearInterval(interval);
            clearTimeout(timeoutId);
            console.warn('jinrishici SDK did not appear after retries');
            if (infoEl) infoEl.textContent = '（今日詩詞 SDK 無法載入）';
            adjustFontSizeByLength(sentenceEl);
          }
        }, 50);
      }
    } catch (err) {
      console.error('jinrishici init error:', err);
      if (infoEl) infoEl.textContent = '（載入今日詩詞時發生錯誤）';
      adjustFontSizeByLength(sentenceEl);
      clearTimeout(timeoutId);
    }
  })();
</script>
